# -*- coding: utf-8 -*-
"""DijkstraAlgorithm

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gRJkmNAAnT_04_uRopDwOC_6Co4VzM3J

# Libraries
"""

import random
import numpy as np
from numpy import Inf

import time
import timeit
from datetime import datetime
from time import process_time

import math
from matplotlib import pyplot as plt
from matplotlib.pyplot import figure

import networkx as nx
import heapq
from collections import defaultdict

"""# Part A: Dijkstra Algorithm with Array as Priority Queue

*   Input graph G = (V, E) stored in an adjacency matrix
*   Array used for Priority Queue

#### Part A: Helper Function, Random Matrix Graph Generator

where n = number of vertices
where e = number of edges with weight, where (e >= n - 1)
"""

def adj_matrix_graph_generator(n, e, maxWeight):
    adjMatrix = [[0 for i in range(n)] for j in range(n)]

    while (e != 0):
        a = random.randint(0, n-1)
        b = random.randint(0, n-1)
        
        if a != b and adjMatrix[a][b] == 0:
          adjMatrix[a][b] = 1
          e -= 1

    for i in range(n):
        for j in range(n):
            if (adjMatrix[i][j] == 1):
                adjMatrix[i][j] = random.randint(1, maxWeight)
    
    return adjMatrix

"""#### Part A: Implementation"""

def dijkstra_matrix_array(adjMatrix, sourceNode):
    d = [] # array of estimates for lengths of shortest paths from source node
    pi = [] # array of predecessors for each vertex
    S =  [] # set of vertices whose shortest path from source already determined
    priorityQueue = [] # Priority Queue Q

    infinity = 9999999 # alternatively infinity = (float('inf'))
    graphLength = len(adjMatrix)

    for i in range(graphLength): # for each vertex v
        d.append(infinity) # set distance to infinity, d[v] = infinity
        # pi.append(None) # set predecessor to NULL, pi[v] = null
        pi.append(-1) # set predecessor to NULL, pi[v] = null
        S.append(0) # set solution set S to empty at first, where all v not in S

        # put all vertices in Priority Queue Q in d[v]'s increasing order
        priorityQueue.append(i)

    d[sourceNode] = 0 # set estimated distance to itself (src to src) to be 0

    while len(priorityQueue) != 0: # if Q not empty
        # Implementation of u = ExtractCheapest(Q)
        cheapest = 0
        for i in range(len(priorityQueue)):
            if (d[priorityQueue[i]] < d[priorityQueue[cheapest]]):
                cheapest = i;
        u = priorityQueue.pop(cheapest)

        S[u] = 1 # add u to S

        for i in range(graphLength): # for each vertex v adjacent to u
            vertex = i;
            weight = adjMatrix[u][i]

            if (weight > 0):
                # if vertex v not in solution set & estimated distance distance
                # of vertex v bigger than src node + weighted edge[u, v]
                if ((S[vertex] != 1) and (d[vertex] > (d[u] + weight))):
                    d[vertex] = d[u] + weight # update the new shortest value
                    pi[vertex] = u # set predecessor of vertex v as u

    return d, pi

"""#### Part A: Testing Graphs"""

def newAdjacencyMatrix(n, p):
    G = nx.generators.gnp_random_graph(n, p)
    nx.draw(G, with_labels=True)

    A = nx.adjacency_matrix(G).toarray()

    edges = int(sum(sum(A)) / 2)

    randnums = np.random.randint(2, 10, 10000)

    # generate weights
    for i in range(n):
        for j in range(n):
            if A[i][j] == 1:
                A[i][j] = A[j][i] = randnums[0]
                randnums = np.delete(randnums, 0)
    return A, edges

adjMatrixTest, noOfEdges = newAdjacencyMatrix(5, 1)
print(adjMatrixTest)
print(noOfEdges)

print("")

def convert_to_adjacency_list(graph, n):
    adjacency_list = defaultdict(list)
    for i in range(n):
        for j in range(n):
            if graph[i][j] != 0:
                adjacency_list[i].append((j, graph[i][j]))
    return adjacency_list

adjacency_list = convert_to_adjacency_list(adjMatrixTest, 5)
print(adjacency_list)

def print_adjList(adjList):
    for i in adjList:
        print(i, end="")
        for j in adjList[i]:
            print(" -> {}".format(j), end="")
        print()

print_adjList(adjacency_list)

adjMatrixTest = adj_matrix_graph_generator(3, 4, 100)
print(adjMatrixTest)
print("\n")
for i in adjMatrixTest:
    print(i)

adjMatrix = [[0, 4, 0, 0, 0, 0, 0, 8, 0],
             [4, 0, 8, 0, 0, 0, 0, 11, 0],
             [0, 8, 0, 7, 0, 4, 0, 0, 2],
             [0, 0, 7, 0, 9, 14, 0, 0, 0],
             [0, 0, 0, 9, 0, 10, 0, 0, 0],
             [0, 0, 4, 14, 10, 0, 2, 0, 0],
             [0, 0, 0, 0, 0, 2, 0, 1, 6 ],
             [8, 11, 0, 0, 0, 0, 1, 0, 7],
             [0, 0, 2, 0, 0, 0, 6, 7, 0]]

startTime = time.perf_counter()
d, pi = dijkstra_matrix_array(adjMatrix, 0)
endTime = time.perf_counter()
totalTime = endTime-startTime

print(d)
print(pi)
print(totalTime)

"""#### Part A: Plotting Graphs"""

# Testing Complete Graph
# e = n * (n -1)

complete = {"x": [], "y": []}

for n in range(3, 100):
    complete["x"].append(n)

    e = n * (n -1)
    adjMatrix = adj_matrix_graph_generator(n, e, 100)

    startTime = datetime.now()
    start = process_time()

    dijkstra_matrix_array(adjMatrix, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    complete["y"].append(runtimeMS)

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(complete["x"], complete["y"], label = "complete", color = "orange")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part A: Runtime of Dijkstra's Algorithm using an Adjacency Matrix, Array as Priority Queue (Complete Graph)")
plt.grid()
plt.legend()
plt.show()

# Testing Incomplete Graph
# e = n + 1

incomplete = {"x": [], "y": []}

for n in range(3, 100):
    incomplete["x"].append(n)

    e = n + 1
    adjMatrix = adj_matrix_graph_generator(n, e, 100)

    startTime = datetime.now()
    start = process_time()

    dijkstra_matrix_array(adjMatrix, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    incomplete["y"].append(runtimeMS)

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(incomplete["x"], incomplete["y"], label = "incomplete", color = "blue")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part A: Runtime of Dijkstra's Algorithm using an Adjacency Matrix, Array as Priority Queue (Incomplete Graph)")
plt.grid()
plt.legend()
plt.show()

# Testing Complete and Incomplete Graph
# Complete: e = n * (n -1)
# Incomplete: e = n + 1

complete = {"x": [], "y": []}
incomplete = {"x": [], "y": []}

for n in range(3, 100):
    complete["x"].append(n)

    e = n * (n -1)
    adjMatrix = adj_matrix_graph_generator(n, e, 100)

    startTime = datetime.now()
    start = process_time()

    dijkstra_matrix_array(adjMatrix, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    complete["y"].append(runtimeMS)

for n in range(3, 100):
    incomplete["x"].append(n)

    e = n + 1
    adjMatrix = adj_matrix_graph_generator(n, e, 100)

    startTime = datetime.now()
    start = process_time()

    dijkstra_matrix_array(adjMatrix, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    incomplete["y"].append(runtimeMS)

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(complete["x"], complete["y"], label = "complete", color = "orange")
plt.plot(incomplete["x"], incomplete["y"], label = "incomplete", color = "blue")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part A: Runtime of Dijkstra's Algorithm using an Adjacency Matrix, Array as Priority Queue")
plt.grid()
plt.legend()
plt.show()

"""**NOTE: NEED TO DO AVERAGE**"""

# Testing Complete and Incomplete Graph
# Complete: e = n * (n -1)
# Incomplete: e = n + 1

complete = {"x": [], "y": []}
incomplete = {"x": [], "y": []}

n = 4
for x in range(9):
    complete["x"].append(n)

    print("complete n = ", n)
    e = n * (n -1)
    adjMatrix = adj_matrix_graph_generator(n, e, 100)

    startTime = datetime.now()
    start = process_time()

    dijkstra_matrix_array(adjMatrix, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    complete["y"].append(runtimeMS)
    n = n * 2

n = 4
for x in range(9):
    incomplete["x"].append(n)

    print("incomplete n = ", n)
    e = n + 1
    adjMatrix = adj_matrix_graph_generator(n, e, 100)

    startTime = datetime.now()
    start = process_time()

    dijkstra_matrix_array(adjMatrix, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    incomplete["y"].append(runtimeMS)
    n = n * 2

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(complete["x"], complete["y"], label = "complete", color = "orange")
plt.plot(incomplete["x"], incomplete["y"], label = "incomplete", color = "blue")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part A: Runtime of Dijkstra's Algorithm using an Adjacency Matrix, Array as Priority Queue")
plt.grid()
plt.legend()
plt.show()

"""# Part B: Dijkstra Algorithm with Minimizing Heap as Priority Queue

*   Input graph G = (V, E) stored in an array of adjacency lists
*   Minimizing Heap used for Priority Queue

#### Part B: Helper Function, Converting Adjacency Matrix to Adjacency Lists
"""

def convert_matrix_to_list(adjMatrix):
    adjList = {}
    lengthOfAdjMatrix = len(adjMatrix)

    for i in range(0, lengthOfAdjMatrix):
        adjList[i] = []
        for j in range(0, lengthOfAdjMatrix):
            if adjMatrix[i][j] != 0:
                adjList[i].append((j, adjMatrix[i][j]))

    return adjList

"""#### Part B: Helper Function, Class Definition for a Minimizing Heap as Prority Queue

"""

def alt_dijkstra_lists_heap(graph, root):
    n = len(graph)
    # set up "inf" distances
    dist = [Inf for _ in range(n)]
    # set up root distance
    dist[root] = 0
    # set up visited node list
    visited = [False for _ in range(n)]
    # set up priority queue
    pq = [(0, root)]
    # while there are nodes to process
    while len(pq) > 0:
        # get the root, discard current distance
        _, u = heapq.heappop(pq)
        # if the node is visited, skip
        if visited[u]:
            continue
        # set the node to visited
        visited[u] = True
        # check the distance and node and distance
        for v, l in graph[u]:
            # if the current node's distance + distance to the node we're visiting
            # is less than the distance of the node we're visiting on file
            # replace that distance and push the node we're visiting into the priority queue
            if dist[u] + l < dist[v]:
                dist[v] = dist[u] + l
                heapq.heappush(pq, (dist[v], v))
    return dist

class minHeap():
    def __init__(self):
        self.array = []
        self.position = []

    def swapHeapNode(self, a, b):
        # swap a and b
        temp = self.array[a]
        self.array[a] = self.array[b]
        self.array[b] = temp

    def heapify(self, index):
        # start heapifying at index parameter
        small = index
        left = (2 * index) + 1
        right = (2 * index) + 2

        if ((left < len(self.array)) and (self.array[left][1] < self.array[small][1])):
            small = left
        if ((right < len(self.array)) and (self.array[right][1] < self.array[small][1])):
            small = right

        if small != index:
            self.position[self.array[small][0]] = index
            self.position[self.array[index][0]] = small

            self.swapHeapNode(small, index)
            self.heapify(small)
    
    def takeMin(self):
        if len(self.array) == 0:
            return

        root = self.array[0]
        last = self.array[(len(self.array) - 1)]
        self.array[0] = last

        self.position[last[0]] = 0
        self.position[root[0]] = len(self.array) - 1

        self.array.pop(len(self.array) - 1)
        self.heapify(0)

        return root

    def updateNode(self, vertex, weight):
        index = self.position[vertex]
        self.array[index][1] = weight

        while ((index > 0) and (self.array[index][1] < self.array[(index-1)//2][1])):
            self.position[self.array[index][0]] = (index-1)//2
            self.position[self.array[(index-1)//2][0]] = index
            self.swapHeapNode(index, (index-1)//2)

            index = (index-1)//2

"""#### Part B: Implementation"""

def dijkstra_lists_heap(adjList, sourceNode):
    d = [] # array of estimates for lengths of shortest paths from source node
    pi = [] # array of predecessors for each vertex
    S =  [] # set of vertices whose shortest path from source already determined
    # alternatively can use import heapq.. 
    # ie heapq.heappop(pq)
    # ie heapq.heappush(pq, (dist[v]), v))
    heap = minHeap()

    infinity = 9999999 # alternatively infinity = (float('inf'))
    graphLength = len(adjList)

    for i in range(graphLength): # for each vertex v
        d.append(infinity) # set distance to infinity, d[v] = infinity
        # pi.append(None) # set predecessor to NULL, pi[v] = null
        pi.append(-1) # set predecessor to NULL, pi[v] = null
        S.append(0) # set solution set S to empty at first, where all v not in S

        heap.array.append([i, d[i]])
        heap.position.append(i)

    d[sourceNode] = 0 # set estimated distance to itself (src to src) to be 0
    heap.updateNode(sourceNode, d[sourceNode])

    while len(heap.array) != 0: # if heap not empty
        # Extracting cheapest from Heap
        u = heap.takeMin()[0]

        S[u] = 1 # add u to S

        for edge in adjList[u]: # for each vertex v adjacent to u
            vertex = edge[0];

            if (heap.position[vertex] < len(heap.array)):
                # if vertex v not in solution set & estimated distance distance
                # of vertex v bigger than src node + weighted edge[u, v]
                if ((S[vertex] != 1) and (d[vertex] > (edge[1] + d[u]))):
                    d[vertex] = edge[1] + d[u] # update the new shortest value
                    pi[vertex] = u # set predecessor of vertex v as u
                    heap.updateNode(vertex, d[vertex])

    return d, pi

"""#### Part B: Testing Graphs"""

adjMatrixTest = adj_matrix_graph_generator(3, 4, 100)
# print(adjMatrixTest)
for i in adjMatrixTest:
    print(i)

print("\n")
adjListTest = convert_matrix_to_list(adjMatrixTest)
print(adjListTest)

"""#### Part B: Plotting Graphs"""

# Testing Complete Graph
# e = n * (n -1)

complete = {"x": [], "y": []}

for n in range(3, 100):
    complete["x"].append(n)

    e = n * (n -1)
    adjMatrix = adj_matrix_graph_generator(n, e, 100)
    adjList = convert_matrix_to_list(adjMatrix)

    startTime = datetime.now()
    start = process_time()

    dijkstra_lists_heap(adjList, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    complete["y"].append(runtimeMS)

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(complete["x"], complete["y"], label = "complete", color = "orange")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part B: Runtime of Dijkstra's Algorithm using an array of Adjacency Lists, Minimizing Heap as Priority Queue (Complete Graph)")
plt.grid()
plt.legend()
plt.show()

# Testing Incomplete Graph
# e = n + 1

incomplete = {"x": [], "y": []}

for n in range(3, 100):
    incomplete["x"].append(n)

    e = n + 1
    adjMatrix = adj_matrix_graph_generator(n, e, 100)
    adjList = convert_matrix_to_list(adjMatrix)

    startTime = datetime.now()
    start = process_time()

    dijkstra_lists_heap(adjList, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    incomplete["y"].append(runtimeMS)

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(incomplete["x"], incomplete["y"], label = "incomplete", color = "blue")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part B: Runtime of Dijkstra's Algorithm using an array of Adjacency Lists, Minimizing Heap as Priority Queue (Incomplete Graph)")
plt.grid()
plt.legend()
plt.show()

# Testing Complete and Incomplete Graph
# Complete: e = n * (n -1)
# Incomplete: e = n + 1

complete = {"x": [], "y": []}
incomplete = {"x": [], "y": []}

for n in range(3, 100):
    complete["x"].append(n)

    e = n * (n -1)
    adjMatrix = adj_matrix_graph_generator(n, e, 100)
    adjList = convert_matrix_to_list(adjMatrix)

    startTime = datetime.now()
    start = process_time()

    dijkstra_lists_heap(adjList, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    complete["y"].append(runtimeMS)

for n in range(3, 100):
    incomplete["x"].append(n)

    e = n + 1
    adjMatrix = adj_matrix_graph_generator(n, e, 100)
    adjList = convert_matrix_to_list(adjMatrix)

    startTime = datetime.now()
    start = process_time()

    dijkstra_lists_heap(adjList, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    incomplete["y"].append(runtimeMS)

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(complete["x"], complete["y"], label = "complete", color = "orange")
plt.plot(incomplete["x"], incomplete["y"], label = "incomplete", color = "blue")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part B: Runtime of Dijkstra's Algorithm using an array of Adjacency Lists, Minimizing Heap as Priority Queue")
plt.grid()
plt.legend()
plt.show()

"""**NOTE: NEED TO DO AVERAGE**"""

# Testing Complete and Incomplete Graph
# Complete: e = n * (n -1)
# Incomplete: e = n + 1

complete = {"x": [], "y": []}
incomplete = {"x": [], "y": []}

n = 4
for x in range(9):
    complete["x"].append(n)

    print("complete n = ", n)
    e = n * (n -1)
    adjMatrix = adj_matrix_graph_generator(n, e, 100)
    adjList = convert_matrix_to_list(adjMatrix)

    startTime = datetime.now()
    start = process_time()

    dijkstra_lists_heap(adjList, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    complete["y"].append(runtimeMS)
    n = n * 2

n = 4
for x in range(9):
    incomplete["x"].append(n)

    print("incomplete n = ", n)
    e = n + 1
    adjMatrix = adj_matrix_graph_generator(n, e, 100)
    adjList = convert_matrix_to_list(adjMatrix)

    startTime = datetime.now()
    start = process_time()

    dijkstra_lists_heap(adjList, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    incomplete["y"].append(runtimeMS)
    n = n * 2

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(complete["x"], complete["y"], label = "complete", color = "orange")
plt.plot(incomplete["x"], incomplete["y"], label = "incomplete", color = "blue")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part B: Runtime of Dijkstra's Algorithm using an array of Adjacency Lists, Minimizing Heap as Priority Queue")
plt.grid()
plt.legend()
plt.show()

"""# Part C: Comparing Dijkstra Algorithm with Array & Minimizing Heap as Priority Queue

#### Part C: Comparing Part A & B on Complete Graphs
"""

# Testing Complete Graph
# Complete: e = n * (n - 1)

partAcomplete = {"x": [], "y": []}
partBcomplete = {"x": [], "y": []}

for n in range(3, 100):
    partAcomplete["x"].append(n)

    partAtotalTime = 0

    for average_loop in range(1, 11):
        e = n * (n - 1)
        adjMatrix = adj_matrix_graph_generator(n, e, 100)

        startTime = datetime.now()
        start = process_time()

        dijkstra_matrix_array(adjMatrix, 0)

        stopTime = datetime.now()
        stop = process_time()

        runtimeS = (stop - start)
        runtimeMS = (stop - start) * 1000

        partAtotalTime = partAtotalTime + runtimeMS

    runtimeMS = partAtotalTime/10
    partAcomplete["y"].append(runtimeMS)

for n in range(3, 100):
    partBcomplete["x"].append(n)

    partBtotalTime = 0

    for average_loop in range(1, 11):
        e = n * (n - 1)
        adjMatrix = adj_matrix_graph_generator(n, e, 100)
        adjList = convert_matrix_to_list(adjMatrix)

        startTime = datetime.now()
        start = process_time()

        # alt_dijkstra_lists_heap(adjList, 0) # ALT CODE
        dijkstra_lists_heap(adjList, 0)

        stopTime = datetime.now()
        stop = process_time()

        runtimeS = (stop - start)
        runtimeMS = (stop - start) * 1000

        partBtotalTime = partBtotalTime + runtimeMS

    partBtotalTime = partBtotalTime/10
    partBcomplete["y"].append(runtimeMS)

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(partAcomplete["x"], partAcomplete["y"], label = "Part A: Adjacency Matrix, Array as Priority Queue", color = "green")
plt.plot(partBcomplete["x"], partBcomplete["y"], label = "Part B: Adjacency Lists, Heap as Priority Queue", color = "purple")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part C: Runtime of Different Dijkstra's Algorithm using on Complete Graphs")
plt.grid()
plt.legend()
plt.show()

"""**NOTE: NEED TO DO AVERAGE**"""

# Testing Complete Graph
# Complete: e = n * (n - 1)

partAcomplete = {"x": [], "y": []}
partBcomplete = {"x": [], "y": []}

n = 4
for x in range(9):
    partAcomplete["x"].append(n)

    print("Part A Complete n = ", n)
    e = n * (n - 1)
    adjMatrix = adj_matrix_graph_generator(n, e, 100)

    startTime = datetime.now()
    start = process_time()

    dijkstra_matrix_array(adjMatrix, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    partAcomplete["y"].append(runtimeMS)
    n = n * 2

n = 4
for x in range(9):
    partBcomplete["x"].append(n)

    print("Part B Complete n = ", n)
    e = n * (n - 1)
    adjMatrix = adj_matrix_graph_generator(n, e, 100)
    adjList = convert_matrix_to_list(adjMatrix)

    startTime = datetime.now()
    start = process_time()

    # alt_dijkstra_lists_heap(adjList, 0) # ALT_CODE
    dijkstra_lists_heap(adjList, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    partBcomplete["y"].append(runtimeMS)
    n = n * 2

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(partAcomplete["x"], partAcomplete["y"], label = "Part A: Adjacency Matrix, Array as Priority Queue", color = "green")
plt.plot(partBcomplete["x"], partBcomplete["y"], label = "Part B: Adjacency Lists, Heap as Priority Queue", color = "purple")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part C: Runtime of Different Dijkstra's Algorithm using on Complete Graphs")
plt.grid()
plt.legend()
plt.show()

# GETTING NUMBERS ONLY

n = 1024
e = n * (n - 1)

partAtotalTime = 0

for average_loop in range(1, 4):
    adjMatrix = adj_matrix_graph_generator(n, e, 100)

    startTime = datetime.now()
    start = process_time()

    dijkstra_matrix_array(adjMatrix, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    partAtotalTime = partAtotalTime + runtimeMS

runtimeMS = partAtotalTime/3
print("AVERAGE RUNTIME FOR PART A: ", runtimeMS)


n = 1024
e = n * (n - 1)

partBtotalTime = 0

for average_loop in range(1, 4):
    adjMatrix = adj_matrix_graph_generator(n, e, 100)
    adjList = convert_matrix_to_list(adjMatrix)

    startTime = datetime.now()
    start = process_time()

    dijkstra_lists_heap(adjList, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    partBtotalTime = partBtotalTime + runtimeMS

runtimeMS = partBtotalTime/3
print("AVERAGE RUNTIME FOR PART B: ", runtimeMS)

"""#### Part C: Comparing Part A & B on Incomplete Graphs


"""

# Testing Incomplete Graph
# Incomplete: e = n + 1

partAincomplete = {"x": [], "y": []}
partBincomplete = {"x": [], "y": []}

for n in range(3, 100):
    partAincomplete["x"].append(n)

    partAtotalTime = 0

    for average_loop in range(1, 11):
        e = n + 1
        adjMatrix = adj_matrix_graph_generator(n, e, 100)

        startTime = datetime.now()
        start = process_time()

        dijkstra_matrix_array(adjMatrix, 0)

        stopTime = datetime.now()
        stop = process_time()

        runtimeS = (stop - start)
        runtimeMS = (stop - start) * 1000

        partAtotalTime = partAtotalTime + runtimeMS

    runtimeMS = partAtotalTime/10
    partAincomplete["y"].append(runtimeMS)

for n in range(3, 100):
    partBincomplete["x"].append(n)

    partBtotalTime = 0

    for average_loop in range(1, 11):
        e = n + 1
        adjMatrix = adj_matrix_graph_generator(n, e, 100)
        adjList = convert_matrix_to_list(adjMatrix)

        startTime = datetime.now()
        start = process_time()

        dijkstra_lists_heap(adjList, 0)

        stopTime = datetime.now()
        stop = process_time()

        runtimeS = (stop - start)
        runtimeMS = (stop - start) * 1000

    partBtotalTime = partBtotalTime/10
    partBincomplete["y"].append(runtimeMS)

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(partAincomplete["x"], partAincomplete["y"], label = "Part A: Adjacency Matrix, Array as Priority Queue", color = "green")
plt.plot(partBincomplete["x"], partBincomplete["y"], label = "Part B: Adjacency Lists, Heap as Priority Queue", color = "purple")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part C: Runtime of Different Dijkstra's Algorithm using on Incomplete Graphs")
plt.grid()
plt.legend()
plt.show()

"""**NOTE: NEED TO DO AVERAGE**

"""

# Testing Incomplete Graph
# Incomplete: e = n + 1

partAincomplete = {"x": [], "y": []}
partBincomplete = {"x": [], "y": []}

n = 4
for x in range(9):
    partAincomplete["x"].append(n)

    print("Part A Incomplete n = ", n)
    e = n + 1
    adjMatrix = adj_matrix_graph_generator(n, e, 100)

    startTime = datetime.now()
    start = process_time()

    dijkstra_matrix_array(adjMatrix, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    partAincomplete["y"].append(runtimeMS)
    n = n * 2

n = 4
for x in range(9):
    partBincomplete["x"].append(n)

    print("Part B Incomplete n = ", n)
    e = n + 1
    adjMatrix = adj_matrix_graph_generator(n, e, 100)
    adjList = convert_matrix_to_list(adjMatrix)

    startTime = datetime.now()
    start = process_time()

    dijkstra_lists_heap(adjList, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    partBincomplete["y"].append(runtimeMS)
    n = n * 2

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(partAincomplete["x"], partAincomplete["y"], label = "Part A: Adjacency Matrix, Array as Priority Queue", color = "green")
plt.plot(partBincomplete["x"], partBincomplete["y"], label = "Part B: Adjacency Lists, Heap as Priority Queue", color = "purple")

plt.xlabel("number of vertices n")
plt.ylabel("Time (ms)")

plt.title("Part C: Runtime of Different Dijkstra's Algorithm using on Incomplete Graphs")
plt.grid()
plt.legend()
plt.show()

# GETTING NUMBERS ONLY

n = 1024
e = n + 1

partAtotalTime = 0

for average_loop in range(1, 21):
    adjMatrix = adj_matrix_graph_generator(n, e, 100)

    startTime = datetime.now()
    start = process_time()

    dijkstra_matrix_array(adjMatrix, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    partAtotalTime = partAtotalTime + runtimeMS

runtimeMS = partAtotalTime/20
print("AVERAGE RUNTIME FOR PART A: ", runtimeMS)


n = 1024
e = n + 1

partBtotalTime = 0

for average_loop in range(1, 21):
    adjMatrix = adj_matrix_graph_generator(n, e, 100)
    adjList = convert_matrix_to_list(adjMatrix)

    startTime = datetime.now()
    start = process_time()

    dijkstra_lists_heap(adjList, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    partBtotalTime = partBtotalTime + runtimeMS

runtimeMS = partBtotalTime/20
print("AVERAGE RUNTIME FOR PART B: ", runtimeMS)

"""#### Part C: Comparing Part A & B on Complete Graphs, 
##### where n = 500 and e is incremented by 2000 until a Complete Graph is reached.


"""

# Testing Complete Graph
# Complete: e = n * (n - 1)

partAcomplete = {"x": [], "y": []}
partBcomplete = {"x": [], "y": []}

n = 500
e = n

while(e <= n * (n - 1)):
    partAcomplete["x"].append(e)

    adjMatrix = adj_matrix_graph_generator(n, e, 100)

    startTime = datetime.now()
    start = process_time()

    dijkstra_matrix_array(adjMatrix, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    partAcomplete["y"].append(runtimeMS)
    # print("n = ", n, " e = ", e)
    e += 2000

n = 500
e = n

while(e <= n * (n - 1)):
    partBcomplete["x"].append(e)

    adjMatrix = adj_matrix_graph_generator(n, e, 100)
    adjList = convert_matrix_to_list(adjMatrix)

    startTime = datetime.now()
    start = process_time()

    dijkstra_lists_heap(adjList, 0)

    stopTime = datetime.now()
    stop = process_time()

    runtimeS = (stop - start)
    runtimeMS = (stop - start) * 1000

    partBcomplete["y"].append(runtimeMS)
    # print("n = ", n, " e = ", e)
    e += 2000

fig = plt.figure()
fig.set_size_inches(15, 10)
    
plt.plot(partAcomplete["x"], partAcomplete["y"], label = "Part A: Adjacency Matrix, Array as Priority Queue", color = "green")
plt.plot(partBcomplete["x"], partBcomplete["y"], label = "Part B: Adjacency Lists, Heap as Priority Queue", color = "purple")

plt.xlabel("number of edges e")
plt.ylabel("Time (ms)")

plt.title("Part C: Runtime of Different Dijkstra's Algorithm using on Complete Graphs")
plt.grid()
plt.legend()
plt.show()

"""#### Part C: Comparing Time Complexity between Part A & B with respect to |V| and |E|

**Adjacency Matrix**: Array as Priority Queue

Transversal using Adjacency Matrix

= V x number of edges each vertex is connected to

= V x (V-1)

= V^2 - V

= O(|V|^2)


Implementation of array for priority queue

= O(1)  ***insertion into array is constant time***


Therefore, overall time complexity

= O(|V|^2 + 1) 

= O(|V|^2)

**Adjacency Lists**: Minimizing Heap as Priority Queue

Transversal using Adjacency List 

= O(|E|+|V|) 

Implementation of heap for priority queue

= O (log (|V|))

Overall time complexity 

= O(|E|+|V|) x O (log (|V|))

= O ((|E|+|V|) log |V|)

= O(|E| log|V|)
"""